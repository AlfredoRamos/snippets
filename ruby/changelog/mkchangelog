#!/usr/bin/env ruby
# encoding: UTF-8
$stdout.sync = $stderr.sync = true

require 'logger'

class Changelog

  VERSION = '0.1.3'

  def initialize
    # Logger
    setup_logger

    # Config values
    # TO-DO: Read values from file
    @config = {
      :format => {
        :title => '## Changelog',
        :heading => '%3$s### %1$s%2$s',
        :item => '* [%h] %s - *%aN*'
      },
      :file => 'CHANGELOG.md'
    }
  end

  def generate
    begin
      # Write file
      write

      # Check if file was created
      if File.exist?(@config[:file])
        @logger.info('File %s created successfully' % @config[:file])
      end
    rescue => ex
      @logger.error(ex.message)
    end
  end

  def setup_logger
    @logger = Logger.new($stdout)
    @logger.formatter = proc do |severity, datetime, progname, msg|
      '[%1$s] %2$s :: %3$s%4$s' % [severity, datetime, msg, "\n"]
    end
  end

  def get_tags
    tags = `git for-each-ref --sort=taggerdate --format='%(refname:strip=2)|%(taggerdate:short)' refs/tags`
    tags = tags.split(/\n/).sort_by! do |ver|
      v = ver.split('|')
      Gem::Version.new(v.first)
    end
    tags = tags.reverse!
    data = []

    tags.each do |tag|
      t = tag.split('|')
      d = {
        :tag => t.first,
        :date => t.last
      }
      # Fix for lightweight tags
      d[:date] = nil if d[:tag] == d[:date]
      data.push(d)
    end

    data
  end

  def get_base_url
    url = `git remote get-url --push origin`
    url.chomp!.chomp!('.git')
  end

  def write
    # Check if it's a git repository
    if !Dir.exist?('.git')
      raise 'Not a git repository'
    end

    tags = get_tags

    # Create file in current directory
    File.open(@config[:file], 'w') do |md|

      # Title
      md.puts @config[:format][:title]

      # Iterate each tag
      tags.each_with_index do |data, index|
        nextref = (index <= 0) ? {:tag => 'master', :date => nil} : tags[index - 1]

        # Git log
        log = `git log --format='#{@config[:format][:item]}' #{data[:tag]}..#{nextref[:tag]}`

        # Only write to file if tag has commits to show
        if !log.empty?
          # Write tag and date
          md.puts @config[:format][:heading] % [
            nextref[:tag],
            (nextref[:date].nil? ? '' : " - #{nextref[:date]}"),
            "\n"
          ]

          # Write tag commits
          md.puts log

          # Print first tag
          if index == (tags.length - 1)
            # Tag and date
            md.puts @config[:format][:heading] % [
              tags.last[:tag],
              " - #{tags.last[:date]}",
              "\n"
            ]

            # Tag commits
            log = `git log --format='#{@config[:format][:item]}' #{tags.last[:tag]}`
            md.puts log
          end

        end

      end

    end

  end

end

# Generate changelog
Changelog.new.generate
